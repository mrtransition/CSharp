using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace _14改进
{
    class Program
    {
        /*
         * ·对象初始化器
         * ·var类型，类型推理
         * ·匿名类型
         * dynamic类型
         * 命名和可选的方法参数
         * 扩展方法
         * Lambda表达式 
         */

        /*
         * 初始化器
         * 可以使用初始化器在创建对象或集合的同时初始化它们。
         * 这两种初始化器都包括一个放在花括号中的代码块。
         * 对象初始化器可以提供一个逗号分隔的属性名/值对列表，来设置属性值。
         * 集合初始化器仅需要逗号分割的值列表。
         * 使用对象删除化器时，还可以使用非默认的构造函数。
         */
        /*
         * 类型推理
         * 声明变量时，使用var关键字允许忽略变量的类型。
         * 但只有类型可以在编译期间确定时才会如此。
         * 使用var没有违反C#的强类型化规则，因为var声明的变量只有一个类型。
         * 
         */

        /*
         * 匿名类型
         * 对于用于结构数据存储的许多简单类型，定义类型是不必要的。而可以使用匿名类型，其成员根据用途来推断。
         * 使用对象初始化器语法来地冠以匿名类型，每个设置的属性都定义为只读属性。
         * 
          */
        /*
         * 动态查找
         * 使用dynamic关键字定义dynamic类型的变量，可以存储任意值，接着就可以使用一般的属性或方法语法来访问被包含的值的成员，
         * 这些成员仅在运行期间检查。如果在运行期间，尝试访问一个不存在的成员，就会抛出一个异常。
         * 这种动态的类型化显著简化了访问.Net类型或类型信息补能在编译期间获得的.Net类型的语法。但是，在使用时动态类型要谨慎，
         * 因为无法在编译期间检查代码。
         * 在IDynamicMetaObjectProvider接口，可以控制动态查找的行为。
         */

        /*
         * 可选的方法参数
         * 可以提供多个方法重载，而无不是强制客户代码为很少使用的参数提供值。
         * 另外，也可以把这些参数定义为可选参数。调用方法的客户代码就可以仅指定需要的参数。
         */

        /*
         * 命名的方法参数
         * 客户代码可以根据位置或名称来指定方法的参数。
         * 命名的参数可以按任意顺序指定。这尤其适用于和可选参数一起使用的场合。
         */

        /*
         * 扩展方法
         * 可以为任意已有的类型定义扩展方法，而无需修改类型定义。
         * 创建通用的扩展方法的另一种方式是创建可以通过特定接口使用的扩展方法
         */
         /*
          * Lambda表达式
          * Lambda表达式实际上是定义匿名方法的一种快捷方式，且由额外的功能，例如隐式的类型化。
          * 定义Lambda表达式时，需要使用逗号分隔的参数列表（如果没有参数，就是用空括号）、=>运算符
          * 和一表达式。该表达式可以是放在花括号中的代码块。
          * Lambda表达式至多可以有8个参数和一个可选的返回类型。
          * Lambda表达式可以用Action、Action<>和Func<>委托类型来表示。
          * 许多可用于集合的LINQ扩展方法都使用Lambda表达式参数。
          */
        static void Main(string[] args)
        {
        }
    }
}
